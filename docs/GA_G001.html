<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<head>
    <title>Layered Nodes</title>
    <link rel="stylesheet" href="GA_Pages.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-120550704-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-120550704-1');
    </script>
    <!--jQuery api host from Google-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
    <h2>G001 - Layered Nodes</h2>
    <h5>Matthew Yu</h5>
    <h5>October 26th, 2018</h5>
    <hr>
    <p>
        This program experiments with layered nodes and connecting nodes in a
        branching out circular pattern. Pretty simple.
    </p>
    <p>
        Each node consists of a x and a y coordinate.
        It starts with a shape in the center, a set of nodes that are vertices
        to a polygon. Then for each vertice, <i>a</i> amount of nodes are connected
        to it. This occurs for up to <i>k</i> layers until your browser starts
        freezing, trying to process so many shapes. I've found that the program
        works decently smoothly up to around 1400 nodes, with the following settings.
    </p>
    <ul>
        <li>n: base nodes = 7</li>
        <li>a: number of nodes per node for successive layers = 3</li>
        <li>k: number of layers = 6</li>
        <li>r: radius of each layer = 60</li>
    </ul>
    <p>
        The equation that models the number of nodes total is:
        <script type="math/tex">\sum\limits_{i=1}^k n*a^{i-1}</script>
        <br>With the current parameters, I get 1456 nodes. If I add another layer, my
        nodes spike up to 4372.
    </p>
    <p>
        I connected the nodes as triangulish polygons, with one node from the previous
        layer and a nodes from the current layer, and then filled them in with a
        random color using Perlin noise.
        My basic output would be something like this:
    </p>
    <!--Insert Layered_Nodes_0.png here-->
    <img src="description\G001\Layered_Nodes_0.PNG">
    <p>
        With more layers, you tend to see higher layers devolve into darkness since
        there is a larger node density despite the increased radius size. Therefore
        layers beyond 7 are probably not going to look very interesting.
    </p>
    <!--Insert Layered_Nodes_1.png here-->
    <img src="description\G001\Layered_Nodes_1.PNG">
    <p>
        So after drawing a static image, the next rational thing to do is to make
        it dynamic. So I added rotation for each layer, based on the framecount of
        the program.
    </p>
    <!--Insert Layered_Nodes_2.png here-->
    <img src="description\G001\Layered_Nodes_2.PNG">
    <p>
        Tada! A rotating eyeball! Let's add an offset to each layer (but just
        enough so it doesn't cause layers to come out of each other).
    </p>
    <!--Insert Layered_Nodes_3.png here-->
    <img src="description\G001\Layered_Nodes_3.PNG">
    <hr>
    <h3>Additional things from this program:</h3>
    <p>
        The coordinates of each node are determined are generated from the <i>sine</i>
        and <i>cosine</i> functions. I used the following formulas:
    </p>
    <div align="center">
        <script type="math/tex">
            x=radius \times layer \times \cos{(\frac{2 \times \pi \times node}{Max Layer Nodes})}+xOffset
        </script>
    </div>
    <div align="center">
        <script style="align:center;" type="math/tex">
            y=radius \times layer \times \sin{(\frac{2 \times \pi \times node}{Max Layer Nodes})}+yOffset
        </script>
    </div>
    <p>
        where I cycled through each node for each layer. Each node in a layer
        was pushed to a set called a <i>nodeLayer</i>, and each nodeLayer was pushed
        into an all encompassing set <i>nodes</i>.
        <br>
        Creating these node sets enabled me to draw shapes based on their vertices
        and color them in, as well as make them spin, using p5's rotate() function.
    </p>
    <hr>
    <p>
        Here's a gallery of some of the Generative Art I've created with this program.
    </p>
    <!--G001 gallery-->
    <div class="flex-container">
        <section>
            <button class="accordion"><h2>G001</h2></button>
            <div id="G001Gallery" class="panel"></div>
            <script>
                let G001Container = document.getElementById("G001Gallery");
                let G001Pictures = ["png", "aligningMirors", "circleStructure", "eyeball", "mechanicalSun", "rotatingDrums"];
                for (let i = 1; i < G001Pictures.length; i++) {
                    let src = "pictures/G001_Drawings/" + G001Pictures[i] + "." + G001Pictures[0];
                    let img = new Image();
                    img.src = src;
                    G001Container.appendChild(img);
                }
            </script>
        </section>
    </div>

    <!--expander for galleries-->
    <script src="gallery-expander.js"></script>
</body>
<footer>
    This page is part of a project to document and effectively communicate code
    and algorithms to people.
    <div class="flex-container">
        <a href="index.html">
            <img src="icons/home.png" style="float:center;border:0;">
        </a>
    </div>
    <div class="flex-container">
</footer>
